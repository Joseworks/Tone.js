<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Tone.js Source: signal/Expr.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	
	<link type="text/css" rel="stylesheet" href="styles/site.spacelab.css">
	
</head>

<body>
<div class="container-fluid">
	<div class="navbar navbar-fixed-top ">
		<div class="navbar-inner">
			<a class="brand" href="index.html">Tone.js</a>
			<ul class="nav">
				
				<li class="dropdown">
					<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b
						class="caret"></b></a>

					<ul class="dropdown-menu ">
						
						<li>
							<a href="Tone.html">Tone</a>
						</li>
						
						<li>
							<a href="Tone.Abs.html">Abs</a>
						</li>
						
						<li>
							<a href="Tone.Add.html">Add</a>
						</li>
						
						<li>
							<a href="Tone.AmplitudeEnvelope.html">AmplitudeEnvelope</a>
						</li>
						
						<li>
							<a href="Tone.AMSynth.html">AMSynth</a>
						</li>
						
						<li>
							<a href="Tone.AND.html">AND</a>
						</li>
						
						<li>
							<a href="Tone.AudioToGain.html">AudioToGain</a>
						</li>
						
						<li>
							<a href="Tone.AutoPanner.html">AutoPanner</a>
						</li>
						
						<li>
							<a href="Tone.AutoWah.html">AutoWah</a>
						</li>
						
						<li>
							<a href="Tone.BitCrusher.html">BitCrusher</a>
						</li>
						
						<li>
							<a href="Tone.Buffer.html">Buffer</a>
						</li>
						
						<li>
							<a href="Tone.Chebyshev.html">Chebyshev</a>
						</li>
						
						<li>
							<a href="Tone.Chorus.html">Chorus</a>
						</li>
						
						<li>
							<a href="Tone.Clip.html">Clip</a>
						</li>
						
						<li>
							<a href="Tone.Clock.html">Clock</a>
						</li>
						
						<li>
							<a href="Tone.Compressor.html">Compressor</a>
						</li>
						
						<li>
							<a href="Tone.Convolver.html">Convolver</a>
						</li>
						
						<li>
							<a href="Tone.Distortion.html">Distortion</a>
						</li>
						
						<li>
							<a href="Tone.Divide.html">Divide</a>
						</li>
						
						<li>
							<a href="Tone.DryWet.html">DryWet</a>
						</li>
						
						<li>
							<a href="Tone.DuoSynth.html">DuoSynth</a>
						</li>
						
						<li>
							<a href="Tone.Effect.html">Effect</a>
						</li>
						
						<li>
							<a href="Tone.Envelope.html">Envelope</a>
						</li>
						
						<li>
							<a href="Tone.EQ.html">EQ</a>
						</li>
						
						<li>
							<a href="Tone.Equal.html">Equal</a>
						</li>
						
						<li>
							<a href="Tone.EqualPowerGain.html">EqualPowerGain</a>
						</li>
						
						<li>
							<a href="Tone.EqualZero.html">EqualZero</a>
						</li>
						
						<li>
							<a href="Tone.Expr.html">Expr</a>
						</li>
						
						<li>
							<a href="Tone.FeedbackCombFilter.html">FeedbackCombFilter</a>
						</li>
						
						<li>
							<a href="Tone.FeedbackDelay.html">FeedbackDelay</a>
						</li>
						
						<li>
							<a href="Tone.FeedbackEffect.html">FeedbackEffect</a>
						</li>
						
						<li>
							<a href="Tone.Filter.html">Filter</a>
						</li>
						
						<li>
							<a href="Tone.FMSynth.html">FMSynth</a>
						</li>
						
						<li>
							<a href="Tone.Follower.html">Follower</a>
						</li>
						
						<li>
							<a href="Tone.Freeverb.html">Freeverb</a>
						</li>
						
						<li>
							<a href="Tone.Gate.html">Gate</a>
						</li>
						
						<li>
							<a href="Tone.GreaterThan.html">GreaterThan</a>
						</li>
						
						<li>
							<a href="Tone.GreaterThanZero.html">GreaterThanZero</a>
						</li>
						
						<li>
							<a href="Tone.IfThenElse.html">IfThenElse</a>
						</li>
						
						<li>
							<a href="Tone.Instrument.html">Instrument</a>
						</li>
						
						<li>
							<a href="Tone.Inverse.html">Inverse</a>
						</li>
						
						<li>
							<a href="Tone.JCReverb.html">JCReverb</a>
						</li>
						
						<li>
							<a href="Tone.LessThan.html">LessThan</a>
						</li>
						
						<li>
							<a href="Tone.LFO.html">LFO</a>
						</li>
						
						<li>
							<a href="Tone.Limiter.html">Limiter</a>
						</li>
						
						<li>
							<a href="Tone.LowpassCombFilter.html">LowpassCombFilter</a>
						</li>
						
						<li>
							<a href="Tone.Master.html">Master</a>
						</li>
						
						<li>
							<a href="Tone.Max.html">Max</a>
						</li>
						
						<li>
							<a href="Tone.Merge.html">Merge</a>
						</li>
						
						<li>
							<a href="Tone.Meter.html">Meter</a>
						</li>
						
						<li>
							<a href="Tone.Microphone.html">Microphone</a>
						</li>
						
						<li>
							<a href="Tone.MidSideEffect.html">MidSideEffect</a>
						</li>
						
						<li>
							<a href="Tone.Min.html">Min</a>
						</li>
						
						<li>
							<a href="Tone.Modulo.html">Modulo</a>
						</li>
						
						<li>
							<a href="Tone.Mono.html">Mono</a>
						</li>
						
						<li>
							<a href="Tone.Monophonic.html">Monophonic</a>
						</li>
						
						<li>
							<a href="Tone.MonoSynth.html">MonoSynth</a>
						</li>
						
						<li>
							<a href="Tone.MultibandCompressor.html">MultibandCompressor</a>
						</li>
						
						<li>
							<a href="Tone.MultibandSplit.html">MultibandSplit</a>
						</li>
						
						<li>
							<a href="Tone.Multiply.html">Multiply</a>
						</li>
						
						<li>
							<a href="Tone.MultiSampler.html">MultiSampler</a>
						</li>
						
						<li>
							<a href="Tone.Negate.html">Negate</a>
						</li>
						
						<li>
							<a href="Tone.Noise.html">Noise</a>
						</li>
						
						<li>
							<a href="Tone.NoiseSynth.html">NoiseSynth</a>
						</li>
						
						<li>
							<a href="Tone.Normalize.html">Normalize</a>
						</li>
						
						<li>
							<a href="Tone.NOT.html">NOT</a>
						</li>
						
						<li>
							<a href="Tone.Note.html">Note</a>
						</li>
						
						<li>
							<a href="Tone.OmniOscillator.html">OmniOscillator</a>
						</li>
						
						<li>
							<a href="Tone.OR.html">OR</a>
						</li>
						
						<li>
							<a href="Tone.Oscillator.html">Oscillator</a>
						</li>
						
						<li>
							<a href="Tone.Panner.html">Panner</a>
						</li>
						
						<li>
							<a href="Tone.PanVol.html">PanVol</a>
						</li>
						
						<li>
							<a href="Tone.Phaser.html">Phaser</a>
						</li>
						
						<li>
							<a href="Tone.PingPongDelay.html">PingPongDelay</a>
						</li>
						
						<li>
							<a href="Tone.Player.html">Player</a>
						</li>
						
						<li>
							<a href="Tone.PluckSynth.html">PluckSynth</a>
						</li>
						
						<li>
							<a href="Tone.PolySynth.html">PolySynth</a>
						</li>
						
						<li>
							<a href="Tone.Pow.html">Pow</a>
						</li>
						
						<li>
							<a href="Tone.PulseOscillator.html">PulseOscillator</a>
						</li>
						
						<li>
							<a href="Tone.PWMOscillator.html">PWMOscillator</a>
						</li>
						
						<li>
							<a href="Tone.Recorder.html">Recorder</a>
						</li>
						
						<li>
							<a href="Tone.Route.html">Route</a>
						</li>
						
						<li>
							<a href="Tone.Sampler.html">Sampler</a>
						</li>
						
						<li>
							<a href="Tone.Scale.html">Scale</a>
						</li>
						
						<li>
							<a href="Tone.ScaledEnvelope.html">ScaledEnvelope</a>
						</li>
						
						<li>
							<a href="Tone.ScaleExp.html">ScaleExp</a>
						</li>
						
						<li>
							<a href="Tone.Select.html">Select</a>
						</li>
						
						<li>
							<a href="Tone.Signal.html">Signal</a>
						</li>
						
						<li>
							<a href="Tone.SignalBase.html">SignalBase</a>
						</li>
						
						<li>
							<a href="Tone.Source.html">Source</a>
						</li>
						
						<li>
							<a href="Tone.Split.html">Split</a>
						</li>
						
						<li>
							<a href="Tone.StereoEffect.html">StereoEffect</a>
						</li>
						
						<li>
							<a href="Tone.StereoFeedbackEffect.html">StereoFeedbackEffect</a>
						</li>
						
						<li>
							<a href="Tone.StereoWidener.html">StereoWidener</a>
						</li>
						
						<li>
							<a href="Tone.StereoXFeedbackEffect.html">StereoXFeedbackEffect</a>
						</li>
						
						<li>
							<a href="Tone.Subtract.html">Subtract</a>
						</li>
						
						<li>
							<a href="Tone.Switch.html">Switch</a>
						</li>
						
						<li>
							<a href="Tone.Threshold.html">Threshold</a>
						</li>
						
						<li>
							<a href="Tone.Transport.html">Transport</a>
						</li>
						
						<li>
							<a href="Tone.WaveShaper.html">WaveShaper</a>
						</li>
						

					</ul>
				</li>
				
			</ul>
		</div>
	</div>

	<div class="row-fluid">

		
			<div class="span12">
				
				<div id="main">
					


		<h1 class="page-title">Source: signal/Expr.js</h1>
    
    <section>
        <article>
            <pre class="sunlight-highlight-javascript linenums">define(["Tone/core/Tone", "Tone/signal/Add", "Tone/signal/Subtract", "Tone/signal/Multiply", 
	"Tone/signal/IfThenElse", "Tone/signal/OR", "Tone/signal/AND", "Tone/signal/NOT", 
	"Tone/signal/GreaterThan", "Tone/signal/LessThan", "Tone/signal/Equal", "Tone/signal/EqualZero", 
	"Tone/signal/GreaterThanZero", "Tone/signal/Abs", "Tone/signal/Negate", "Tone/signal/Max", 
	"Tone/signal/Min", "Tone/signal/Modulo", "Tone/signal/Inverse", "Tone/signal/Divide", "Tone/signal/Pow"], 
	function(Tone){

	"use strict";

	/**
	 *  @class evaluate an expression at audio rate. 
	 *         parsing code modified from https://code.google.com/p/tapdigit/
	 *         Copyright 2011 2012 Ariya Hidayat, New BSD License
	 *
	 *  @extends {Tone.SignalBase}
	 *  @constructor
	 *  @param {string} expr the expression to generate
	 */
	Tone.Expr = function(){

		var expr = this._replacements(Array.prototype.slice.call(arguments));
		var inputCount = this._parseInputs(expr);

		/**
		 *  hold onto all of the nodes for disposal
		 *  @type {Array}
		 *  @private
		 */
		this._nodes = [];

		/**
		 *  the inputs
		 *  @type {Array}
		 */
		this.input = new Array(inputCount);

		//create a gain for each input
		for (var i = 0; i &lt; inputCount; i++){
			this.input[i] = this.context.createGain();
		}

		//parse the syntax tree
		var tree = this._parseTree(expr);
		//evaluate the results
		var result;
		try {
			result = this._eval(tree);
		} catch (e){
			this._disposeNodes();
			throw new Error("Could evaluate expression: "+expr);
		}

		/**
		 *  the output node is the result of the expression
		 *  @type {*}
		 */
		this.output = result;
	};

	Tone.extend(Tone.Expr, Tone.SignalBase);

	//some helpers to cut down the amount of code
	function applyBinary(Constructor, args, self){
		var op = new Constructor();
		self._eval(args[0]).connect(op, 0, 0);
		self._eval(args[1]).connect(op, 0, 1);
		return op;
	}
	function applyUnary(Constructor, args, self){
		var op = new Constructor();
		self._eval(args[0]).connect(op, 0, 0);
		return op;
	}
	function getNumber(arg){
		return arg ? parseFloat(arg) : undefined;
	}
	function literalNumber(arg){
		return arg && arg.args ? parseFloat(arg.args) : undefined;
	}

	/*
	 *  the Expressions that Tone.Expr can parse.
	 *
	 *  each expression belongs to a group and contains a regexp 
	 *  for selecting the operator as well as that operators method
	 *  
	 *  @type {Object}
	 *  @private
	 */
	Tone.Expr._Expressions = {
		//values
		"value" : {
			"signal" : {
				regexp : /^\d+\.\d+|^\d+/,
				method : function(arg){
					var sig = new Tone.Signal(getNumber(arg));
					return sig;
				}
			},
			"input" : {
				regexp : /^\$\d/,
				method : function(arg, self){
					return self.input[getNumber(arg.substr(1))];
				}
			}
		},
		//syntactic glue
		"glue" : {
			"(" : {
				regexp : /^\(/,
			},
			")" : {
				regexp : /^\)/,
			},
			"," : {
				regexp : /^,/,
			}
		},
		//functions
		"func" : {
			"abs" :  {
				regexp : /^abs/,
				method : applyUnary.bind(this, Tone.Abs)
			},
			"min" : {
				regexp : /^min/,
				method : applyBinary.bind(this, Tone.Min)
			},
			"max" : {
				regexp : /^max/,
				method : applyBinary.bind(this, Tone.Max)
			},
			"if" :  {
				regexp : /^if/,
				method : function(args, self){
					var op = new Tone.IfThenElse();
					self._eval(args[0]).connect(op.if);
					self._eval(args[1]).connect(op.then);
					self._eval(args[2]).connect(op.else);
					return op;
				}
			},
			"gt0" : {
				regexp : /^gt0/,
				method : applyUnary.bind(this, Tone.GreaterThanZero)
			},
			"eq0" : {
				regexp : /^eq0/,
				method : applyUnary.bind(this, Tone.EqualZero)
			},
			"inv" : {
				regexp : /^inv/,
				method : function(args, self){
					var precision = literalNumber(args[1]);
					var op = new Tone.Inverse(precision);
					self._eval(args[0]).connect(op);
					return op;
				}
			},
			"mod" : {
				regexp : /^mod/,
				method : function(args, self){
					var modulus = literalNumber(args[1]);
					var bits = literalNumber(args[2]);
					var op = new Tone.Modulo(modulus, bits);
					self._eval(args[0]).connect(op);
					return op;
				}
			},
			"pow" : {
				regexp : /^pow/,
				method : function(args, self){
					var exp = literalNumber(args[1]);
					var op = new Tone.Pow(exp);
					self._eval(args[0]).connect(op);
					return op;
				}
			},
		},
		//binary expressions
		"binary" : {
			"+" : {
				regexp : /^\+/,
				precedence : 1,
				method : applyBinary.bind(this, Tone.Add)
			},
			"-" : {
				regexp : /^\-/,
				precedence : 1,
				method : function(args, self){
					//both unary and binary op
					if (args.length === 1){
						return applyUnary(Tone.Negate, args, self);
					} else {
						return applyBinary(Tone.Subtract, args, self);
					}
				}
			},
			"*" : {
				regexp : /^\*/,
				precedence : 0,
				method : applyBinary.bind(this, Tone.Multiply)
			},
			"/" : {
				regexp : /^\//,
				precedence : 0,
				method : applyBinary.bind(this, Tone.Divide)
			},
			">" : {
				regexp : /^\>/,
				precedence : 2,
				method : applyBinary.bind(this, Tone.GreaterThan)
			},
			"&lt;" : {
				regexp : /^&lt;/,
				precedence : 2,
				method : applyBinary.bind(this, Tone.LessThan)
			},
			"==" : {
				regexp : /^==/,
				precedence : 3,
				method : applyBinary.bind(this, Tone.Equal)
			},
			"&&" : {
				regexp : /^&&/,
				precedence : 4,
				method : applyBinary.bind(this, Tone.AND)
			},
			"||" : {
				regexp : /^\|\|/,
				precedence : 5,
				method : applyBinary.bind(this, Tone.OR)
			},
		},
		//unary expressions
		"unary" : {
			"-" : {
				regexp : /^\-/,
				method : applyUnary.bind(this, Tone.Negate)
			},
			"!" : {
				regexp : /^\!/,
				method : applyUnary.bind(this, Tone.NOT)
			},
		},
	};
		
	/**
	 *  @param   {string} expr the expression string
	 *  @return  {number}      the input count
	 *  @private
	 */
	Tone.Expr.prototype._parseInputs = function(expr){
		var inputArray = expr.match(/\$\d/g);
		var inputMax = 0;
		if (inputArray !== null){
			for (var i = 0; i &lt; inputArray.length; i++){
				var inputNum = parseInt(inputArray[i].substr(1)) + 1;
				inputMax = Math.max(inputMax, inputNum);
			}
		}
		return inputMax;
	};

	/**
	 *  @param   {Array} args 	an array of arguments
	 *  @return  {string} the results of the replacements being replaced
	 *  @private
	 */
	Tone.Expr.prototype._replacements = function(args){
		var expr = args.shift();
		for (var i = 0; i &lt; args.length; i++){
			expr = expr.replace(/\%/i, args[i]);
		}
		return expr;
	};

	/**
	 *  tokenize the expression based on the Expressions object
	 *  @param   {string} expr 
	 *  @return  {Object}      returns two methods on the tokenized list, next and peek
	 *  @private
	 */
	Tone.Expr.prototype._tokenize = function(expr){
		var position = -1;
		var tokens = [];

		while(expr.length > 0){
			expr = expr.trim();
			var token =  getNextToken(expr);
			tokens.push(token);
			expr = expr.substr(token.value.length);
		}

		function getNextToken(expr){
			for (var type in Tone.Expr._Expressions){
				var group = Tone.Expr._Expressions[type];
				for (var opName in group){
					var op = group[opName];
					var reg = op.regexp;
					var match = expr.match(reg);
					if (match !== null){
						return {
							type : type,
							value : match[0],
							method : op.method
						};
					}
				}
			}
			throw new SyntaxError("Unexpected token "+expr);
		}

		return {
			next : function(){
				return tokens[++position];
			},
			peek : function(){
				return tokens[position + 1];
			}
		};
	};

	/**
	 *  recursively parse the string expression into a syntax tree
	 *  
	 *  @param   {string} expr 
	 *  @return  {Object}
	 *  @private
	 */
	Tone.Expr.prototype._parseTree = function(expr){
		var lexer = this._tokenize(expr);
		var isUndef = this.isUndef.bind(this);

		function matchSyntax(token, syn) {
			return !isUndef(token) && 
				token.type === "glue" &&
				token.value === syn;
		}

		function matchGroup(token, groupName, prec) {
			var ret = false;
			var group = Tone.Expr._Expressions[groupName];
			if (!isUndef(token)){
				for (var opName in group){
					var op = group[opName];
					if (op.regexp.test(token.value)){
						if (!isUndef(prec)){
							if(op.precedence === prec){	
								return true;
							}
						} else {
							return true;
						}
					}
				}
			}
			return ret;
		}

		function parseExpression(precedence) {
			if (isUndef(precedence)){
				precedence = 5;
			}
			var expr;
			if (precedence &lt; 0){
				expr = parseUnary();
			} else {
				expr = parseExpression(precedence-1);
			}
			var token = lexer.peek();
			while (matchGroup(token, "binary", precedence)) {
				token = lexer.next();
				expr = {
					operator: token.value,
					method : token.method,
					args : [
						expr,
						parseExpression(precedence)
					]
				};
				token = lexer.peek();
			}
			return expr;
		}

		function parseUnary() {
			var token, expr;
			token = lexer.peek();
			if (matchGroup(token, "unary")) {
				token = lexer.next();
				expr = parseUnary();
				return {
					operator: token.value,
					method : token.method,
					args : [expr]
				};
			}
			return parsePrimary();
		}

		function parsePrimary() {
			var token, expr;
			token = lexer.peek();
			if (isUndef(token)) {
				throw new SyntaxError("Unexpected termination of expression");
			}
			if (token.type === "func") {
				token = lexer.next();
				return parseFunctionCall(token);
			}
			if (token.type === "value") {
				token = lexer.next();
				return {
					method : token.method,
					args : token.value
				};
			}
			if (matchSyntax(token, "(")) {
				lexer.next();
				expr = parseExpression();
				token = lexer.next();
				if (!matchSyntax(token, ")")) {
					throw new SyntaxError("Expected )");
				}
				return expr;
			}
			throw new SyntaxError("Parse error, cannot process token " + token.value);
		}

		function parseFunctionCall(func) {
			var token, args = [];
			token = lexer.next();
			if (!matchSyntax(token, "(")) {
				throw new SyntaxError("Expected ( in a function call \"" + func.value + "\"");
			}
			token = lexer.peek();
			if (!matchSyntax(token, ")")) {
				args = parseArgumentList();
			}
			token = lexer.next();
			if (!matchSyntax(token, ")")) {
				throw new SyntaxError("Expected ) in a function call \"" + func.value + "\"");
			}
			return {
				method : func.method,
				args : args,
				name : name
			};
		}

		function parseArgumentList() {
			var token, expr, args = [];
			while (true) {
				expr = parseExpression();
				if (isUndef(expr)) {
					// TODO maybe throw exception?
					break;
				}
				args.push(expr);
				token = lexer.peek();
				if (!matchSyntax(token, ",")) {
					break;
				}
				lexer.next();
			}
			return args;
		}

		return parseExpression();
	};

	/**
	 *  recursively evaluate the expression tree
	 *  @param   {Object} tree 
	 *  @return  {AudioNode}      the resulting audio node from the expression
	 *  @private
	 */
	Tone.Expr.prototype._eval = function(tree){
		if (!this.isUndef(tree)){
			var node = tree.method(tree.args, this);
			this._nodes.push(node);
			return node;
		} 
	};

	/**
	 *  dispose all the nodes
	 *  @private
	 */
	Tone.Expr.prototype._disposeNodes = function(){
		for (var i = 0; i &lt; this._nodes.length; i++){
			var node = this._nodes[i];
			if (typeof node.dispose === "function") {
				node.dispose();
			} else if (typeof node.disconnect === "function") {
				node.disconnect();
			}
			node = null;
			this._nodes[i] = null;
		}
		this._nodes = null;
	};

	/**
	 *  clean up
	 */
	Tone.Expr.prototype.dispose = function(){
		Tone.prototype.dispose.call(this);
		this._disposeNodes();
	};

	return Tone.Expr;
});</pre>
        </article>
    </section>





				</div>

				<div class="clearfix"></div>
				<footer>
					
					
		<span class="jsdoc-message">
		Documentation generated on Wed Dec 03 2014 22:50:18 GMT-0500 (EST).
		</span>
				</footer>
			</div>

			
			<br clear="both">
		</div>

	</div>
	<script src="scripts/sunlight.js"></script>
	<script src="scripts/sunlight.javascript.js"></script>
	<script src="scripts/sunlight-plugin.doclinks.js"></script>
	<script src="scripts/sunlight-plugin.linenumbers.js"></script>
	<script src="scripts/sunlight-plugin.menu.js"></script>
	<script src="scripts/jquery.min.js"></script>
	<script src="scripts/jquery.scrollTo.js"></script>
	<script src="scripts/jquery.localScroll.js"></script>
	<script src="scripts/bootstrap-dropdown.js"></script>
	<script src="scripts/toc.js"></script>


	<script>  Sunlight.highlightAll({lineNumbers:true,  showMenu: true, enableDoclinks :true}); </script>

	<script>
		$( function () {
			$( "#toc" ).toc( {
				selectors   : "h1,h2,h3,h4",
				showAndHide : false,
				scrollTo    : 60
			} );
			$( "#toc>ul" ).addClass( "nav nav-pills nav-stacked" );
			$( "#main span[id^='toc']" ).addClass( "toc-shim" );

		} );
	</script>

	

</body>
</html>
